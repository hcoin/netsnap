<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeighSnapshotter Developer Documentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 3rem 2rem;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        nav {
            background: #2d3748;
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
        }
        
        nav a {
            color: #cbd5e0;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
        }
        
        nav a:hover {
            color: #fff;
        }
        
        main {
            padding: 2rem;
        }
        
        section {
            margin-bottom: 3rem;
        }
        
        h2 {
            color: #667eea;
            font-size: 2rem;
            margin: 2rem 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #667eea;
        }
        
        h3 {
            color: #4a5568;
            font-size: 1.5rem;
            margin: 1.5rem 0 1rem 0;
        }
        
        h4 {
            color: #2d3748;
            font-size: 1.2rem;
            margin: 1rem 0 0.5rem 0;
        }
        
        h5 {
            color: #4a5568;
            font-size: 1.1rem;
            margin: 0.8rem 0 0.4rem 0;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }
        
        li {
            margin-bottom: 0.5rem;
        }
        
        code {
            background: #f7fafc;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 0.9em;
            color: #e53e3e;
        }
        
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
            border-left: 4px solid #667eea;
        }
        
        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        th {
            background: #667eea;
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 0.8rem 1rem;
            border-bottom: 1px solid #e2e8f0;
        }
        
        tr:nth-child(even) {
            background: #f7fafc;
        }
        
        .info-box {
            background: #ebf8ff;
            border-left: 4px solid #4299e1;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }
        
        .warning-box {
            background: #fffaf0;
            border-left: 4px solid #ed8936;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }
        
        .success-box {
            background: #f0fff4;
            border-left: 4px solid #48bb78;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }
        
        .architecture-diagram {
            background: #f7fafc;
            padding: 1.5rem;
            border-radius: 8px;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
            border: 2px solid #e2e8f0;
            margin: 1rem 0;
        }
        
        footer {
            background: #2d3748;
            color: #cbd5e0;
            text-align: center;
            padding: 2rem;
            margin-top: 3rem;
        }
        
        .state-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .state-card {
            background: #f7fafc;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .state-card h5 {
            margin-top: 0;
            color: #667eea;
        }
        
        .badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }
        
        .comparison-table {
            margin: 2rem 0;
        }
        
        .protocol-section {
            background: #f7fafc;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        @media (max-width: 768px) {
            nav ul {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            main {
                padding: 1rem;
            }
            
            header h1 {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NeighSnapshotter</h1>
            <p>Complete Linux Neighbor Table Query Library</p>
            <p style="font-size: 0.9rem; margin-top: 0.5rem;">ARP • NDP • Bridge FDB</p>
        </header>
        
        <nav>
            <ul>
                <li><a href="#rationale">Rationale</a></li>
                <li><a href="#protocols">Protocols</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#implementation">Implementation</a></li>
                <li><a href="#usage">Usage</a></li>
                <li><a href="#api">API Reference</a></li>
                <li><a href="#troubleshooting">Troubleshooting</a></li>
            </ul>
        </nav>
        
        <main>
            <section id="rationale">
                <h2>Design Rationale</h2>
                
                <h3>Why Another Neighbor Table Tool?</h3>
                
                <p>Linux provides several ways to query the neighbor table (ARP/NDP cache), but each has significant limitations:</p>
                
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Limitations</th>
                            <th>Performance</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>/proc/net/arp</code></td>
                            <td>IPv4 only, text parsing, limited fields, no timestamps</td>
                            <td>Moderate</td>
                        </tr>
                        <tr>
                            <td><code>ip neigh show</code></td>
                            <td>Subprocess overhead, text parsing, inconsistent format</td>
                            <td>Slow (15-20ms)</td>
                        </tr>
                        <tr>
                            <td><code>arp -a</code></td>
                            <td>IPv4 only, deprecated, limited information</td>
                            <td>Slow</td>
                        </tr>
                        <tr>
                            <td><code>/proc/net/ndisc_cache</code></td>
                            <td>IPv6 only, text parsing, missing bridge FDB</td>
                            <td>Moderate</td>
                        </tr>
                        <tr>
                            <td><code>bridge fdb show</code></td>
                            <td>Bridge only, subprocess overhead, incomplete data</td>
                            <td>Slow</td>
                        </tr>
                        <tr>
                            <td><code>pyroute2</code></td>
                            <td>Heavy dependency, complex API, slower than native</td>
                            <td>Moderate (8-10ms)</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="success-box">
                    <strong>NeighSnapshotter solves all these problems</strong> by querying the kernel's neighbor table directly via RTNetlink, providing complete information for IPv4 ARP, IPv6 NDP, and bridge FDB in a single unified API with minimal overhead (~2-3ms).
                </div>
                
                <h3>Core Design Principles</h3>
                
                <ol>
                    <li><strong>Direct Kernel Communication</strong>
                        <ul>
                            <li>Uses RTNetlink sockets (RTM_GETNEIGH) for direct kernel queries</li>
                            <li>No text parsing, no external commands, no proc/sys filesystem</li>
                            <li>Single syscall retrieves all neighbor entries</li>
                        </ul>
                    </li>
                    
                    <li><strong>Complete Protocol Coverage</strong>
                        <ul>
                            <li>IPv4 ARP cache entries</li>
                            <li>IPv6 Neighbor Discovery (NDP) cache</li>
                            <li>Bridge Forwarding Database (FDB)</li>
                            <li>All protocol families with unified interface</li>
                        </ul>
                    </li>
                    
                    <li><strong>Full State Information</strong>
                        <ul>
                            <li>All NUD (Neighbor Unreachability Detection) states</li>
                            <li>Flags (PROXY, ROUTER, OFFLOADED, etc.)</li>
                            <li>Cache timestamps (confirmed, used, updated)</li>
                            <li>Hardware type decoding</li>
                        </ul>
                    </li>
                    
                    <li><strong>Type Safety & Validation</strong>
                        <ul>
                            <li>C structures ensure correct data types</li>
                            <li>Python provides clean, JSON-serializable output</li>
                            <li>Unknown attributes tracked for future-proofing</li>
                        </ul>
                    </li>
                    
                    <li><strong>Performance First</strong>
                        <ul>
                            <li>Compiled C code for netlink parsing</li>
                            <li>Minimal Python overhead</li>
                            <li>Bulk queries (all neighbors in one call)</li>
                        </ul>
                    </li>
                </ol>
                
                <h3>Use Cases</h3>
                
                <p>NeighSnapshotter is designed for:</p>
                
                <ul>
                    <li><strong>Network Monitoring:</strong> Track ARP/NDP cache health and changes</li>
                    <li><strong>Security Auditing:</strong> Detect ARP spoofing, rogue neighbors</li>
                    <li><strong>Container Networking:</strong> Inspect bridge FDB for container MAC addresses</li>
                    <li><strong>Troubleshooting:</strong> Debug IPv6 NDP issues, stale entries</li>
                    <li><strong>SDN/OpenFlow:</strong> Monitor learned MAC addresses in bridge FDB</li>
                    <li><strong>Performance Analysis:</strong> Identify neighbor resolution delays</li>
                    <li><strong>Automation:</strong> Integrate neighbor table state into configuration management</li>
                </ul>
            </section>
            
            <section id="protocols">
                <h2>Protocol Deep Dive</h2>
                
                <h3>IPv4 ARP (Address Resolution Protocol)</h3>
                
                <div class="protocol-section">
                    <h4>Overview</h4>
                    <p>ARP resolves IPv4 addresses to MAC addresses on local networks. When a system needs to send a packet to an IPv4 address on the same subnet, it broadcasts an ARP request to find the corresponding MAC address.</p>
                    
                    <h4>Neighbor States for ARP</h4>
                    <div class="state-grid">
                        <div class="state-card">
                            <h5>INCOMPLETE</h5>
                            <p>ARP request sent, waiting for reply</p>
                        </div>
                        <div class="state-card">
                            <h5>REACHABLE</h5>
                            <p>Valid entry, recently confirmed</p>
                        </div>
                        <div class="state-card">
                            <h5>STALE</h5>
                            <p>Entry exists but needs revalidation</p>
                        </div>
                        <div class="state-card">
                            <h5>DELAY</h5>
                            <p>Waiting before sending probe</p>
                        </div>
                        <div class="state-card">
                            <h5>PROBE</h5>
                            <p>Sending unicast ARP probes</p>
                        </div>
                        <div class="state-card">
                            <h5>FAILED</h5>
                            <p>Resolution failed, entry invalid</p>
                        </div>
                        <div class="state-card">
                            <h5>PERMANENT</h5>
                            <p>Static entry, never expires</p>
                        </div>
                        <div class="state-card">
                            <h5>NOARP</h5>
                            <p>No ARP needed (loopback, static)</p>
                        </div>
                    </div>
                    
                    <h4>Common ARP Flags</h4>
                    <ul>
                        <li><strong>PROXY:</strong> This system answers ARP requests on behalf of another</li>
                        <li><strong>ROUTER:</strong> Entry is for a router</li>
                        <li><strong>PERMANENT:</strong> Entry will not be garbage collected</li>
                    </ul>
                </div>
                
                <h3>IPv6 NDP (Neighbor Discovery Protocol)</h3>
                
                <div class="protocol-section">
                    <h4>Overview</h4>
                    <p>NDP is the IPv6 equivalent of ARP, but more sophisticated. It uses ICMPv6 messages for neighbor discovery, address autoconfiguration, router discovery, and redirect messages.</p>
                    
                    <h4>Key Differences from ARP</h4>
                    <ul>
                        <li><strong>Uses ICMPv6</strong> instead of a separate protocol</li>
                        <li><strong>Multicast</strong> instead of broadcast (more efficient)</li>
                        <li><strong>Duplicate Address Detection (DAD)</strong> built-in</li>
                        <li><strong>Router Discovery</strong> integrated</li>
                        <li><strong>Stateless Address Autoconfiguration (SLAAC)</strong> support</li>
                    </ul>
                    
                    <div class="info-box">
                        <strong>Important: NOARP and IPv6</strong>
                        <p>While IPv6 <em>can</em> have NOARP state, it's NOT the normal case. Most IPv6 neighbor entries use NDP (which IS a neighbor resolution protocol) and will show states like REACHABLE, STALE, DELAY, or PROBE.</p>
                        <p><strong>NOARP appears for IPv6 only in special cases:</strong></p>
                        <ul>
                            <li>Loopback address (::1)</li>
                            <li>Point-to-point links where no resolution is needed</li>
                            <li>Static/permanent entries configured manually</li>
                        </ul>
                    </div>
                    
                    <h4>NDP Message Types</h4>
                    <table>
                        <tr>
                            <th>Message</th>
                            <th>Type</th>
                            <th>Purpose</th>
                        </tr>
                        <tr>
                            <td>Neighbor Solicitation (NS)</td>
                            <td>ICMPv6 Type 135</td>
                            <td>Request MAC address for IPv6 (like ARP request)</td>
                        </tr>
                        <tr>
                            <td>Neighbor Advertisement (NA)</td>
                            <td>ICMPv6 Type 136</td>
                            <td>Provide MAC address (like ARP reply)</td>
                        </tr>
                        <tr>
                            <td>Router Solicitation (RS)</td>
                            <td>ICMPv6 Type 133</td>
                            <td>Request router information</td>
                        </tr>
                        <tr>
                            <td>Router Advertisement (RA)</td>
                            <td>ICMPv6 Type 134</td>
                            <td>Announce router presence and prefixes</td>
                        </tr>
                    </table>
                    
                    <h4>NDP-Specific Flags</h4>
                    <ul>
                        <li><strong>ROUTER:</strong> Neighbor is a router (from RA messages)</li>
                        <li><strong>PROXY:</strong> Proxy NDP entry</li>
                    </ul>
                </div>
                
                <h3>Bridge FDB (Forwarding Database)</h3>
                
                <div class="protocol-section">
                    <h4>Overview</h4>
                    <p>The bridge FDB is a Layer 2 forwarding table that maps MAC addresses to bridge ports. Unlike ARP/NDP which operate at Layer 3, the FDB is pure Layer 2.</p>
                    
                    <h4>FDB Learning</h4>
                    <p>Bridges learn MAC addresses by observing traffic:</p>
                    <ol>
                        <li>Frame arrives on port X with source MAC aa:bb:cc:dd:ee:ff</li>
                        <li>Bridge adds entry: "aa:bb:cc:dd:ee:ff is on port X"</li>
                        <li>Future frames to aa:bb:cc:dd:ee:ff are sent only to port X</li>
                        <li>Entries age out after a timeout (default 300s)</li>
                    </ol>
                    
                    <h4>FDB States</h4>
                    <div class="state-grid">
                        <div class="state-card">
                            <h5>PERMANENT</h5>
                            <p>Static entry, never ages out</p>
                        </div>
                        <div class="state-card">
                            <h5>NOARP</h5>
                            <p>Entry added by user/system (not learned)</p>
                        </div>
                        <div class="state-card">
                            <h5>REACHABLE</h5>
                            <p>Dynamically learned, valid</p>
                        </div>
                        <div class="state-card">
                            <h5>STALE</h5>
                            <p>Learned but may need refresh</p>
                        </div>
                    </div>
                    
                    <h4>FDB-Specific Flags</h4>
                    <ul>
                        <li><strong>SELF:</strong> Entry is on the bridge itself</li>
                        <li><strong>MASTER:</strong> Entry is on a bridge port</li>
                        <li><strong>OFFLOADED:</strong> Entry offloaded to hardware (switch ASIC)</li>
                        <li><strong>STICKY:</strong> Entry will not age out</li>
                        <li><strong>EXT_LEARNED:</strong> Learned externally (e.g., from EVPN)</li>
                    </ul>
                    
                    <h4>VLAN Support</h4>
                    <p>When VLAN filtering is enabled on a bridge, FDB entries include VLAN IDs. This allows the same MAC address to exist in multiple VLANs.</p>
                </div>
            </section>
            
            <section id="architecture">
                <h2>Architecture</h2>
                
                <h3>Component Overview</h3>
                
                <div class="architecture-diagram">┌─────────────────────────────────────────────────────────────┐
│                    Python Application                        │
│                 (neighsnapshotter.py)                        │
├─────────────────────────────────────────────────────────────┤
│  NeighborTableQuery Class                                    │
│  ├─ get_neighbors(family=None)                               │
│  │    ├─ family='ipv4'  → IPv4 ARP only                     │
│  │    ├─ family='ipv6'  → IPv6 NDP only                     │
│  │    ├─ family='bridge'→ Bridge FDB only                   │
│  │    └─ family=None    → All neighbor types                │
│  │                                                            │
│  └─ Returns: List[Dict] with complete neighbor metadata     │
├═════════════════════════════════════════════════════════════┤
│                      CFFI Boundary                           │
├═════════════════════════════════════════════════════════════┤
│  C Library (Compiled inline via CFFI)                       │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Socket Management                                    │   │
│  ├─────────────────────────────────────────────────────┤   │
│  │ nl_create_socket()                                   │   │
│  │   └─ socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)    │   │
│  │                                                       │   │
│  │ nl_close_socket()                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Message Construction & Sending                       │   │
│  ├─────────────────────────────────────────────────────┤   │
│  │ nl_send_getneigh(sock, seq, family)                 │   │
│  │   ├─ Creates struct ndmsg                            │   │
│  │   ├─ Sets nlmsg_type = RTM_GETNEIGH                 │   │
│  │   ├─ Sets nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP  │   │
│  │   └─ Sends via send()                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Response Handling                                    │   │
│  ├─────────────────────────────────────────────────────┤   │
│  │ nl_recv_response(sock, expected_seq)                │   │
│  │   ├─ Receives netlink messages via recv()            │   │
│  │   ├─ Buffers and reassembles multi-part responses   │   │
│  │   ├─ Validates sequence numbers                      │   │
│  │   └─ Handles NLMSG_DONE                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Parsing Functions                                    │   │
│  ├─────────────────────────────────────────────────────┤   │
│  │ nl_parse_neighbors(buf, neighbors, count)           │   │
│  │   ├─ Iterates RTM_NEWNEIGH messages                 │   │
│  │   ├─ Extracts struct ndmsg (state, flags, type)     │   │
│  │   ├─ Parses NDA_* attributes:                        │   │
│  │   │   ├─ NDA_DST       → Destination address        │   │
│  │   │   ├─ NDA_LLADDR    → Link-layer address (MAC)   │   │
│  │   │   ├─ NDA_CACHEINFO → Timestamps                 │   │
│  │   │   ├─ NDA_PROBES    → Probe count                │   │
│  │   │   ├─ NDA_VLAN      → VLAN ID                    │   │
│  │   │   └─ NDA_MASTER    → Master interface           │   │
│  │   └─ Tracks unknown attributes                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Helper Functions                                     │   │
│  ├─────────────────────────────────────────────────────┤   │
│  │ nl_get_neigh_state_name(state)                      │   │
│  │   └─ Converts NUD_* bits to human-readable string   │   │
│  │                                                       │   │
│  │ nl_get_neigh_flag_name(flags, index)                │   │
│  │   └─ Converts NTF_* bits to flag names              │   │
│  │                                                       │   │
│  │ nl_get_hw_type_name(type)                           │   │
│  │   └─ Converts ARPHRD_* to hardware type name        │   │
│  └─────────────────────────────────────────────────────┘   │
├═════════════════════════════════════════════════════════════┤
│                      Kernel Boundary                         │
├═════════════════════════════════════════════════════════════┤
│  Linux Kernel                                                │
│                                                               │
│  RTNetlink Subsystem (NETLINK_ROUTE)                        │
│  ├─ Neighbor Table Subsystem                                 │
│  │  ├─ IPv4 ARP cache (net/ipv4/arp.c)                      │
│  │  ├─ IPv6 NDP cache (net/ipv6/ndisc.c)                    │
│  │  └─ Bridge FDB (net/bridge/br_fdb.c)                     │
│  │                                                            │
│  └─ RTM_GETNEIGH Handler                                     │
│     ├─ neigh_dump_table()                                    │
│     ├─ Iterates neighbor hash table                          │
│     └─ Returns RTM_NEWNEIGH messages with NDA_* attributes  │
└─────────────────────────────────────────────────────────────┘</div>
                
                <h3>Data Flow</h3>
                
                <ol>
                    <li><strong>Python initiates query:</strong> <code>ntq.get_neighbors(family='ipv4')</code></li>
                    <li><strong>CFFI calls C function:</strong> <code>nl_send_getneigh(sock, &seq, AF_INET)</code></li>
                    <li><strong>Kernel receives RTM_GETNEIGH:</strong> Triggers neighbor table dump</li>
                    <li><strong>Kernel sends RTM_NEWNEIGH messages:</strong> One per neighbor entry with NDA_* attributes</li>
                    <li><strong>C code buffers responses:</strong> <code>nl_recv_response()</code> collects all messages</li>
                    <li><strong>C code parses messages:</strong> <code>nl_parse_neighbors()</code> extracts data into structures</li>
                    <li><strong>Python receives CFFI structures:</strong> Converts to dictionaries</li>
                    <li><strong>Python enriches data:</strong> Resolves interface names, decodes addresses</li>
                    <li><strong>Returns JSON-serializable result:</strong> Complete neighbor table as Python list</li>
                </ol>
            </section>
            
            <section id="implementation">
                <h2>Implementation Details</h2>
                
                <h3>Key Data Structures</h3>
                
                <h4>C Structures</h4>
                
                <pre><code>// Neighbor cache information
typedef struct {
    unsigned char cacheinfo_confirmed;  // Last confirmed (jiffies)
    unsigned char cacheinfo_used;       // Last used (jiffies)
    unsigned char cacheinfo_updated;    // Last updated (jiffies)
    unsigned char cacheinfo_refcnt;     // Reference count
    int has_cacheinfo_*;                // Presence flags
} neigh_cacheinfo_t;

// Neighbor entry information
typedef struct {
    int ifindex;                        // Interface index
    unsigned char family;               // AF_INET, AF_INET6, AF_BRIDGE
    unsigned char state;                // NUD_* state bits
    unsigned char flags;                // NTF_* flag bits
    unsigned char type;                 // ARPHRD_* hardware type
    unsigned char dst_addr[16];         // Destination IP/MAC
    unsigned char lladdr[32];           // Link-layer address
    int has_dst_addr;                   // Address present
    int has_lladdr;                     // Link-layer address present
    int lladdr_len;                     // Link-layer address length
    unsigned int probes;                // Number of probes sent
    int has_probes;                     // Probes field present
    unsigned short vlan;                // VLAN ID (bridge only)
    int has_vlan;                       // VLAN present
    unsigned int master;                // Master interface (bridge)
    int has_master;                     // Master present
    neigh_cacheinfo_t cacheinfo;        // Cache timing info
    unsigned short unknown_nda_attrs[64]; // Unknown attributes
    int unknown_nda_attrs_count;        // Count of unknown
} neigh_entry_t;</code></pre>
                
                <h4>Python Output Structure</h4>
                
                <pre><code>{
  "ifindex": 2,
  "family": "ipv4",
  "state": 2,
  "state_name": "REACHABLE",
  "flags": 0,
  "flag_names": [],
  "type": 1,
  "type_name": "ETHER",
  "dst": "192.168.1.1",
  "dst_canonical": "192.168.1.1",
  "lladdr": "aa:bb:cc:dd:ee:ff",
  "cacheinfo": {
    "confirmed": 12345,
    "used": 12340,
    "updated": 12345,
    "refcnt": 1
  }
}</code></pre>
                
                <h3>State Machine</h3>
                
                <h4>Neighbor Unreachability Detection (NUD)</h4>
                
                <p>The Linux kernel maintains a state machine for each neighbor entry:</p>
                
                <div class="architecture-diagram">                INCOMPLETE
                     │
                     │ (ARP/NDP reply received)
                     ▼
                REACHABLE ◄────────────────┐
                     │                     │
                     │ (timeout)           │ (traffic confirms reachability)
                     ▼                     │
                  STALE ──────────────────┘
                     │
                     │ (needs revalidation)
                     ▼
                  DELAY
                     │
                     │ (send probe)
                     ▼
                  PROBE
                     │
                     ├─(success)──► REACHABLE
                     │
                     └─(failure)──► FAILED</div>
                
                <h4>State Transitions</h4>
                
                <table>
                    <tr>
                        <th>From State</th>
                        <th>Event</th>
                        <th>To State</th>
                    </tr>
                    <tr>
                        <td>NONE</td>
                        <td>Need to send packet</td>
                        <td>INCOMPLETE</td>
                    </tr>
                    <tr>
                        <td>INCOMPLETE</td>
                        <td>Receive reply</td>
                        <td>REACHABLE</td>
                    </tr>
                    <tr>
                        <td>INCOMPLETE</td>
                        <td>Timeout (no reply)</td>
                        <td>FAILED</td>
                    </tr>
                    <tr>
                        <td>REACHABLE</td>
                        <td>Reachable timeout (~30s)</td>
                        <td>STALE</td>
                    </tr>
                    <tr>
                        <td>STALE</td>
                        <td>Traffic confirms reachability</td>
                        <td>REACHABLE</td>
                    </tr>
                    <tr>
                        <td>STALE</td>
                        <td>Need to send, unconfirmed</td>
                        <td>DELAY</td>
                    </tr>
                    <tr>
                        <td>DELAY</td>
                        <td>Delay timeout (~5s)</td>
                        <td>PROBE</td>
                    </tr>
                    <tr>
                        <td>PROBE</td>
                        <td>Receive reply</td>
                        <td>REACHABLE</td>
                    </tr>
                    <tr>
                        <td>PROBE</td>
                        <td>Max probes reached</td>
                        <td>FAILED</td>
                    </tr>
                </table>
                
                <h3>Attribute Parsing</h3>
                
                <h4>RTNetlink Attribute Format</h4>
                
                <p>Netlink attributes use a Type-Length-Value (TLV) format:</p>
                
                <pre><code>struct rtattr {
    unsigned short rta_len;    // Length including header
    unsigned short rta_type;   // Attribute type (NDA_*)
    // Followed by attribute data
};</code></pre>
                
                <h4>NDA_* Attribute Types</h4>
                
                <table>
                    <tr>
                        <th>Attribute</th>
                        <th>Value</th>
                        <th>Data Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>NDA_DST</td>
                        <td>1</td>
                        <td>IPv4/IPv6/MAC</td>
                        <td>Destination address</td>
                    </tr>
                    <tr>
                        <td>NDA_LLADDR</td>
                        <td>2</td>
                        <td>MAC address</td>
                        <td>Link-layer address</td>
                    </tr>
                    <tr>
                        <td>NDA_CACHEINFO</td>
                        <td>3</td>
                        <td>struct nda_cacheinfo</td>
                        <td>Timing information</td>
                    </tr>
                    <tr>
                        <td>NDA_PROBES</td>
                        <td>4</td>
                        <td>uint32</td>
                        <td>Number of probes sent</td>
                    </tr>
                    <tr>
                        <td>NDA_VLAN</td>
                        <td>5</td>
                        <td>uint16</td>
                        <td>VLAN ID</td>
                    </tr>
                    <tr>
                        <td>NDA_MASTER</td>
                        <td>9</td>
                        <td>uint32</td>
                        <td>Master interface index</td>
                    </tr>
                </table>
                
                <h3>Hardware Type Decoding</h3>
                
                <p>The <code>type</code> field uses ARPHRD_* constants from <code>if_arp.h</code>:</p>
                
                <table>
                    <tr>
                        <th>Constant</th>
                        <th>Value</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>ARPHRD_ETHER</td>
                        <td>1</td>
                        <td>Ethernet (most common)</td>
                    </tr>
                    <tr>
                        <td>ARPHRD_LOOPBACK</td>
                        <td>772</td>
                        <td>Loopback interface</td>
                    </tr>
                    <tr>
                        <td>ARPHRD_IEEE80211</td>
                        <td>801</td>
                        <td>WiFi (802.11)</td>
                    </tr>
                    <tr>
                        <td>ARPHRD_TUNNEL6</td>
                        <td>769</td>
                        <td>IPv6 tunnel</td>
                    </tr>
                    <tr>
                        <td>ARPHRD_VOID</td>
                        <td>0xFFFF</td>
                        <td>No hardware address</td>
                    </tr>
                </table>
            </section>
            
            <section id="usage">
                <h2>Usage Guide</h2>
                
                <h3>Command-Line Interface</h3>
                
                <h4>Basic Usage</h4>
                
                <pre><code># Full JSON output (all neighbor types)
sudo python3 neighsnapshotter.py

# Human-readable summary
sudo python3 neighsnapshotter.py --summary</code></pre>
                
                <h4>Protocol-Specific Queries</h4>
                
                <pre><code># IPv4 ARP only
sudo python3 neighsnapshotter.py --arp --summary

# IPv6 NDP only
sudo python3 neighsnapshotter.py --ndp --summary

# Bridge FDB only
sudo python3 neighsnapshotter.py --bridge --summary</code></pre>
                
                <h4>Interface Filtering</h4>
                
                <pre><code># All neighbors on eth0
sudo python3 neighsnapshotter.py --interface eth0 --summary

# IPv4 ARP on specific interface
sudo python3 neighsnapshotter.py --arp --interface eth0 --summary</code></pre>
                
                <h3>Python API</h3>
                
                <h4>Basic Query</h4>
                
                <pre><code>from neighsnapshotter import NeighborTableQuery

# Query all neighbors
with NeighborTableQuery() as ntq:
    neighbors = ntq.get_neighbors()

# Print all IPv4 ARP entries
for entry in neighbors:
    if entry['family'] == 'ipv4':
        print(f"{entry['dst']} -> {entry.get('lladdr', 'N/A')}")
        print(f"  State: {entry['state_name']}")
        print(f"  Interface: {entry['ifindex']}")</code></pre>
                
                <h4>Protocol-Specific Queries</h4>
                
                <pre><code># Query only IPv4 ARP
with NeighborTableQuery() as ntq:
    arp_entries = ntq.get_neighbors(family='ipv4')

# Query only IPv6 NDP
with NeighborTableQuery() as ntq:
    ndp_entries = ntq.get_neighbors(family='ipv6')

# Query only bridge FDB
with NeighborTableQuery() as ntq:
    fdb_entries = ntq.get_neighbors(family='bridge')</code></pre>
                
                <h4>State Analysis</h4>
                
                <pre><code># Find all failed entries
with NeighborTableQuery() as ntq:
    neighbors = ntq.get_neighbors()

failed = [n for n in neighbors if 'FAILED' in n['state_name']]
print(f"Found {len(failed)} failed neighbor entries:")
for entry in failed:
    print(f"  {entry.get('dst', 'unknown')} on interface {entry['ifindex']}")</code></pre>
                
                <h4>Router Detection</h4>
                
                <pre><code># Find all routers (typically from IPv6 NDP)
with NeighborTableQuery() as ntq:
    neighbors = ntq.get_neighbors(family='ipv6')

routers = [n for n in neighbors if 'ROUTER' in n['flag_names']]
print(f"Found {len(routers)} routers:")
for router in routers:
    print(f"  {router['dst']}")
    print(f"    MAC: {router.get('lladdr', 'N/A')}")
    print(f"    State: {router['state_name']}")</code></pre>
                
                <h4>Bridge FDB Analysis</h4>
                
                <pre><code>import socket

# Analyze bridge FDB entries
with NeighborTableQuery() as ntq:
    fdb = ntq.get_neighbors(family='bridge')

# Group by interface
by_interface = {}
for entry in fdb:
    ifindex = entry['ifindex']
    try:
        ifname = socket.if_indextoname(ifindex)
    except:
        ifname = f"if{ifindex}"
    
    if ifname not in by_interface:
        by_interface[ifname] = []
    by_interface[ifname].append(entry)

# Print statistics
for ifname, entries in sorted(by_interface.items()):
    print(f"{ifname}: {len(entries)} MAC addresses")
    
    # Count by state
    states = {}
    for entry in entries:
        state = entry['state_name']
        states[state] = states.get(state, 0) + 1
    
    for state, count in sorted(states.items()):
        print(f"  {state}: {count}")</code></pre>
                
                <h4>Cache Health Monitoring</h4>
                
                <pre><code>import time

# Monitor cache timing
with NeighborTableQuery() as ntq:
    neighbors = ntq.get_neighbors(family='ipv4')

current_time = int(time.time())

for entry in neighbors:
    if 'cacheinfo' in entry:
        cache = entry['cacheinfo']
        
        # Convert jiffies to seconds (approximate)
        # Note: Actual conversion depends on kernel HZ value
        last_used_sec = cache.get('used', 0) / 100.0
        
        if last_used_sec < 60:
            status = "recently active"
        elif last_used_sec < 300:
            status = "idle"
        else:
            status = "stale"
        
        print(f"{entry['dst']}: {status} (last used ~{last_used_sec:.0f}s ago)")</code></pre>
            </section>
            
            <section id="api">
                <h2>API Reference</h2>
                
                <h3>NeighborTableQuery Class</h3>
                
                <h4>Constructor</h4>
                
                <pre><code>NeighborTableQuery(capture_unknown_attrs=True)</code></pre>
                
                <p><strong>Parameters:</strong></p>
                <ul>
                    <li><code>capture_unknown_attrs</code> (bool): Track unknown netlink attributes (default: True)</li>
                </ul>
                
                <h4>get_neighbors()</h4>
                
                <pre><code>get_neighbors(family: Optional[str] = None) -> List[Dict[str, Any]]</code></pre>
                
                <p><strong>Parameters:</strong></p>
                <ul>
                    <li><code>family</code> (str|None): Protocol family filter
                        <ul>
                            <li><code>'ipv4'</code>: IPv4 ARP only</li>
                            <li><code>'ipv6'</code>: IPv6 NDP only</li>
                            <li><code>'bridge'</code>: Bridge FDB only</li>
                            <li><code>None</code>: All neighbor types (default)</li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>Returns:</strong> List of neighbor entry dictionaries</p>
                
                <p><strong>Raises:</strong></p>
                <ul>
                    <li><code>ValueError</code>: Invalid family parameter</li>
                    <li><code>RuntimeError</code>: Failed to create socket or query kernel</li>
                </ul>
                
                <h3>Neighbor Entry Dictionary</h3>
                
                <h4>Common Fields</h4>
                
                <table>
                    <tr>
                        <th>Field</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>ifindex</td>
                        <td>int</td>
                        <td>Interface index</td>
                    </tr>
                    <tr>
                        <td>family</td>
                        <td>str</td>
                        <td>'ipv4', 'ipv6', or 'bridge'</td>
                    </tr>
                    <tr>
                        <td>state</td>
                        <td>int</td>
                        <td>State bitmask (NUD_* flags)</td>
                    </tr>
                    <tr>
                        <td>state_name</td>
                        <td>str</td>
                        <td>Human-readable state</td>
                    </tr>
                    <tr>
                        <td>flags</td>
                        <td>int</td>
                        <td>Flag bitmask (NTF_* flags)</td>
                    </tr>
                    <tr>
                        <td>flag_names</td>
                        <td>List[str]</td>
                        <td>Human-readable flags</td>
                    </tr>
                    <tr>
                        <td>type</td>
                        <td>int</td>
                        <td>Hardware type (ARPHRD_*)</td>
                    </tr>
                    <tr>
                        <td>type_name</td>
                        <td>str</td>
                        <td>Hardware type name</td>
                    </tr>
                </table>
                
                <h4>Optional Fields</h4>
                
                <table>
                    <tr>
                        <th>Field</th>
                        <th>Type</th>
                        <th>Present When</th>
                    </tr>
                    <tr>
                        <td>dst</td>
                        <td>str</td>
                        <td>Destination address available</td>
                    </tr>
                    <tr>
                        <td>lladdr</td>
                        <td>str</td>
                        <td>Link-layer address available</td>
                    </tr>
                    <tr>
                        <td>probes</td>
                        <td>int</td>
                        <td>Probe count available</td>
                    </tr>
                    <tr>
                        <td>vlan</td>
                        <td>int</td>
                        <td>VLAN ID present (bridge only)</td>
                    </tr>
                    <tr>
                        <td>master</td>
                        <td>int</td>
                        <td>Master interface index present</td>
                    </tr>
                    <tr>
                        <td>cacheinfo</td>
                        <td>Dict</td>
                        <td>Cache timing available</td>
                    </tr>
                </table>
                
                <h4>Cache Info Dictionary</h4>
                
                <table>
                    <tr>
                        <th>Field</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>confirmed</td>
                        <td>int</td>
                        <td>Last confirmed time (jiffies)</td>
                    </tr>
                    <tr>
                        <td>used</td>
                        <td>int</td>
                        <td>Last used time (jiffies)</td>
                    </tr>
                    <tr>
                        <td>updated</td>
                        <td>int</td>
                        <td>Last updated time (jiffies)</td>
                    </tr>
                    <tr>
                        <td>refcnt</td>
                        <td>int</td>
                        <td>Reference count</td>
                    </tr>
                </table>
                
                <div class="info-box">
                    <strong>Note on Jiffies:</strong> Cache timing values are in jiffies (kernel time ticks). To convert to seconds, divide by the kernel's HZ value (typically 100, 250, or 1000). The exact value depends on your kernel configuration.
                </div>
            </section>
            
            <section id="troubleshooting">
                <h2>Troubleshooting</h2>
                
                <h3>Common Issues</h3>
                
                <h4>"Failed to create netlink socket"</h4>
                <div class="warning-box">
                    <p><strong>Cause:</strong> Insufficient permissions</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Run with <code>sudo</code></li>
                        <li>Or grant <code>CAP_NET_ADMIN</code> capability: <code>setcap cap_net_admin+ep python3</code></li>
                    </ul>
                </div>
                
                <h4>"Python 3.12+ requires setuptools"</h4>
                <div class="warning-box">
                    <p><strong>Cause:</strong> CFFI needs setuptools on Python 3.12+</p>
                    <p><strong>Solution:</strong> <code>pip install setuptools</code></p>
                </div>
                
                <h4>Empty Neighbor Table</h4>
                <div class="info-box">
                    <p><strong>Cause:</strong> No neighbors currently cached</p>
                    <p><strong>Diagnosis:</strong></p>
                    <ul>
                        <li>Check if interface is up: <code>ip link show</code></li>
                        <li>Generate traffic to populate cache: <code>ping 192.168.1.1</code></li>
                        <li>For IPv6: <code>ping6 fe80::1%eth0</code></li>
                    </ul>
                </div>
                
                <h4>IPv6 Shows NOARP Instead of NDP States</h4>
                <div class="info-box">
                    <p><strong>This is normal for:</strong></p>
                    <ul>
                        <li>Loopback addresses (::1)</li>
                        <li>Static entries: <code>ip neigh add</code></li>
                        <li>Point-to-point interfaces</li>
                    </ul>
                    <p><strong>If all IPv6 entries show NOARP:</strong> Check if NDP is functioning with <code>ip -6 neigh show</code></p>
                </div>
                
                <h3>Debugging</h3>
                
                <h4>Enable Verbose Output</h4>
                
                <pre><code>import logging
logging.basicConfig(level=logging.DEBUG)

with NeighborTableQuery() as ntq:
    neighbors = ntq.get_neighbors()</code></pre>
                
                <h4>Check Unknown Attributes</h4>
                
                <pre><code># See what attributes the library doesn't recognize
with NeighborTableQuery() as ntq:
    neighbors = ntq.get_neighbors()

for entry in neighbors:
    if 'unknown_nda_attrs_decoded' in entry:
        print(f"Unknown attrs: {entry['unknown_nda_attrs_decoded']}")</code></pre>
                
                <h4>Validate Against ip Command</h4>
                
                <pre><code># Compare with system tools
import subprocess
import json

# Get data from neighsnapshotter
with NeighborTableQuery() as ntq:
    our_data = ntq.get_neighbors(family='ipv4')

# Get data from ip command
result = subprocess.run(['ip', '-j', 'neigh', 'show'], 
                       capture_output=True, text=True)
system_data = json.loads(result.stdout)

print(f"NeighSnapshotter: {len(our_data)} entries")
print(f"ip command: {len(system_data)} entries")</code></pre>
                
                <h3>Performance Tuning</h3>
                
                <h4>Disable Unknown Attribute Tracking</h4>
                
                <pre><code># For production use, disable tracking to reduce overhead
with NeighborTableQuery(capture_unknown_attrs=False) as ntq:
    neighbors = ntq.get_neighbors()</code></pre>
                
                <h4>Filter Early</h4>
                
                <pre><code># Query only what you need
# More efficient than filtering in Python
with NeighborTableQuery() as ntq:
    # Only get IPv4 ARP from kernel
    arp_only = ntq.get_neighbors(family='ipv4')</code></pre>
                
                <h3>Common Patterns</h3>
                
                <h4>Periodic Monitoring</h4>
                
                <pre><code>import time

while True:
    with NeighborTableQuery() as ntq:
        neighbors = ntq.get_neighbors(family='ipv4')
    
    failed = [n for n in neighbors if 'FAILED' in n['state_name']]
    
    if failed:
        print(f"WARNING: {len(failed)} failed ARP entries")
        for entry in failed:
            print(f"  {entry.get('dst', 'unknown')}")
    
    time.sleep(60)  # Check every minute</code></pre>
                
                <h4>Export to JSON File</h4>
                
                <pre><code>import json
from datetime import datetime

with NeighborTableQuery() as ntq:
    neighbors = ntq.get_neighbors()

output = {
    'timestamp': datetime.now().isoformat(),
    'count': len(neighbors),
    'entries': neighbors
}

with open('neighbor_table.json', 'w') as f:
    json.dump(output, f, indent=2)</code></pre>
            </section>
            
            <section>
                <h2>Contributing</h2>
                
                <h3>Code Style</h3>
                <ul>
                    <li><strong>C code:</strong> Linux kernel style (tabs, descriptive names)</li>
                    <li><strong>Python code:</strong> PEP 8 compliant</li>
                    <li><strong>Comments:</strong> Explain "why", not "what"</li>
                </ul>
                
                <h3>Testing</h3>
                <ol>
                    <li>Test with real neighbor entries (generate with <code>ping</code>)</li>
                    <li>Test all protocol families (IPv4, IPv6, bridge)</li>
                    <li>Test edge cases (FAILED states, no entries, etc.)</li>
                    <li>Test on multiple kernel versions if possible</li>
                </ol>
                
                <h3>Adding New Attributes</h3>
                
                <p>To add support for new NDA_* attributes:</p>
                
                <ol>
                    <li>Add to <code>known_nda_attrs</code> array in C code</li>
                    <li>Add case in parsing switch statement</li>
                    <li>Add field to <code>neigh_entry_t</code> structure</li>
                    <li>Update CFFI definitions</li>
                    <li>Add Python decoding logic</li>
                    <li>Update documentation</li>
                </ol>
            </section>
            
            <section>
                <h2>References</h2>
                
                <ul>
                    <li><a href="https://man7.org/linux/man-pages/man7/rtnetlink.7.html">RTNetlink man page</a></li>
                    <li><a href="https://man7.org/linux/man-pages/man8/ip-neighbour.8.html">ip-neighbour(8) man page</a></li>
                    <li><a href="https://datatracker.ietf.org/doc/html/rfc826">RFC 826: ARP</a></li>
                    <li><a href="https://datatracker.ietf.org/doc/html/rfc4861">RFC 4861: IPv6 Neighbor Discovery</a></li>
                    <li><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/neighbour.h">Linux Kernel: neighbour.h</a></li>
                    <li><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/if_arp.h">Linux Kernel: if_arp.h</a></li>
                    <li><a href="https://cffi.readthedocs.io/">CFFI Documentation</a></li>
                </ul>
            </section>
        </main>
        
        <footer>
            <p><strong>NeighSnapshotter Developer Documentation</strong></p>
            <p>Version 1.0 | Last Updated: 2025-01-16</p>
            <p>Complete Linux Neighbor Table Query Library</p>
        </footer>
    </div>
</body>
</html>